// This file has been generated by Py++.

// This file has been generated by Py++.

// This file has been generated by Py++.

// This file has been generated by Py++.

// Copyright (c) 2013 Christoph Koke
//
// Use, modification and distribution is subject to the Boost Software
// License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy
// at http://www.boost.org/LICENSE_1_0.txt)
//
// Header file array.hpp
//
// Indexing algorithms support for std::array instances
//
// History
// =======
//
// $Id: deque.hpp,v 1.1.2.6 2004/02/08 18:57:42 raoulgough Exp $
//

#ifndef BOOST_PYTHON_INDEXING_DEQUE_HPP
#define BOOST_PYTHON_INDEXING_DEQUE_HPP

#include <indexing_suite/container_traits.hpp>
#include <indexing_suite/container_suite.hpp>
#include <indexing_suite/algorithms.hpp>
#include <indexing_suite/suite_utils.hpp>
#include <array>

namespace boost { namespace python { namespace indexing {
  /////////////////////////////////////////////////////////////////////////
  // ContainerTraits implementation for std::list instances
  /////////////////////////////////////////////////////////////////////////

  template <class T>
  class array_value_traits : public simple_value_traits<T>
  {
    BOOST_STATIC_CONSTANT (bool, equality_comparable = has_compare<T>::value);
  };

  template<
	  typename Container,
	  typename ValueTraits = array_value_traits<typename Container::value_type>
  >
  class array_traits
    : public base_container_traits<Container, ValueTraits>
  {
    typedef base_container_traits<Container, ValueTraits> base_class;

  public:
    typedef typename base_class::value_traits_type value_traits_type;

    BOOST_STATIC_CONSTANT(
        method_set_type,
        supported_methods = (
              method_len
            | method_iter
			| method_index
			| method_getitem
			| method_setitem

//            | detail::method_set_if<
//                  value_traits_type::equality_comparable,
//                    method_contains
//                  | method_count
//              >::value

            | detail::method_set_if<
                  base_class::is_mutable,
                  method_reverse
              >::value

//            | detail::method_set_if<
//                  type_traits::ice_and<
//                      base_class::is_mutable,
//                      value_traits_type::less_than_comparable
//                  >::value,
//                  method_sort
//              >::value

        ));
  };

#if !defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION)
  namespace detail {
    ///////////////////////////////////////////////////////////////////////
    // algorithms support for std::array instances
    ///////////////////////////////////////////////////////////////////////

	template <class T, size_t N >
    class algorithms_selector< std::array<T, N> >
    {
      typedef std::array<T, N> Container;

      typedef array_traits<Container>       mutable_traits;
      typedef array_traits<Container const> const_traits;

    public:
      typedef default_algorithms<mutable_traits> mutable_algorithms;
      typedef default_algorithms<const_traits>   const_algorithms;
    };
  }
#endif

  template<
    class Container,
    method_set_type MethodMask = all_methods,
    class Traits = array_traits<Container>
  >
  struct array_suite
    : container_suite<Container, MethodMask, default_algorithms<Traits> >
  {
  };
} } }

#endif // BOOST_PYTHON_INDEXING_DEQUE_HPP












